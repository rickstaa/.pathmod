#!/usr/bin/env bash
## -- PATHMOD bash wrapper --
# A bash script that eases the way of modifying the bash PATH and PYTHONPATH enviromental variables.

# Add Global variables
PATHMOD_PROGNAME="pathmod"
PATHMOD_CONFIG_FILE_NAME="${HOME}/.pathmod_cfg"
PATHMOD_VERSION="1.0.0"

# Unset previoussly set functions and aliases
unset -f _pathmod_load_config_vars
unset -f _pathmod_save_config_vars
unset -f _pathmod_usage
unset -f _pathmod_add_path
unset -f _pathmod_remove_path
unset -f _pathmod_path_exists
unset -f _pathmod_wrapper
unset -f _pathmod_cmdline

# Bash echo colors
ORANGE='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

_pathmod_load_config_vars() {
	# Load saved variables

	if [[ -a "$PATHMOD_CONFIG_FILE_NAME" ]]; then

		# Read variables from file
		while IFS="=" read -r key val; do
			case "$key" in
				'#'*) 
					;; # Skip comments
				'path_export'|'path_display'|'path_guard')
					eval "$key=\"$val\""
					;;
			esac
		done < "$PATHMOD_CONFIG_FILE_NAME"

		# Parse variables to make sure they are alright
		case "$path_export" in
			"true"|"True"|"TRUE"|"false"|"False"|"FALSE")
				;;	
			*)
				# Value was not valid set to default
				path_export=true
				;;
		esac
		case "$path_display" in
			"true"|"True"|"TRUE"|"false"|"False"|"FALSE")
				;;	
			*)
				# Value was not valid set to default
				path_export=false
				;;
		esac
		case "$path_guard" in
			"true"|"True"|"TRUE"|"false"|"False"|"FALSE")
				;;	
			*)
				# Value was not valid set to default
				path_guard=false
				;;
		esac
	else

		# Create file
		{ 
		cat > "$PATHMOD_CONFIG_FILE_NAME" <<- EOL
		# Pathnmod settings
		path_export=true
		path_display=false
		path_guard=false
		EOL
		} || {
			printf "%s:${ORANGE}warning:${NC} Configuration file could not be loaded. Default values were used instead. %s\n" "$PATHMOD_PROGNAME"		
		}

		# Use defaults
		path_export=true
		path_display=false
		path_guard=false
	fi

}

_pathmod_save_config_vars() {
		# Save the pathmod configuration values
		{
		cat >"$PATHMOD_CONFIG_FILE_NAME" <<- EOL
		# Pathnmod settings
		path_export=$path_export
		path_display=$path_display
		path_guard=$path_guard
		EOL
		} || {
			printf "%s:${ORANGE}warning:${NC} Pathmod configuration values could not be saved. %s\n" "$PATHMOD_PROGNAME"		
		}
}

_list_settings() {
	# List current settings and paths
	cat <<- EOF
	current settings and values: $PATHMOD_PROGNAME (v$PATHMOD_VERSION)

	SETTINGS:
	   - Path export: $path_export
	   - Path display: $path_display
	$(_list_path)
	EOF
}

_list_path() {
	# List the current PATH and PYTHONPATH

	# Split PATH and PYTHONPATH into array
	local defaultIFS="$IFS"; IFS=$' \t\n'; local path_tmp=(${PATH//:/ }); IFS="$defaultIFS"
	local defaultIFS="$IFS"; IFS=$' \t\n'; local pythonpath_tmp=(${PYTHONPATH//:/ }); IFS="$defaultIFS"
	
	# Prepent array row number
	for ((i=0;i<${#path_tmp[@]};i++)); do     path_tmp[i]=" - [$i] ${path_tmp[i]}"; done
	for ((i=0;i<${#pythonpath_tmp[@]};i++)); do     pythonpath_tmp[i]=" - [$i] ${pythonpath_tmp[i]}"; done
	
	# Print PATH and PYTHONPATH
	cat <<- EOF

	PATH:
	$(printf "%s\n" "${path_tmp[@]}")

	PYTHONPATH:
	$(printf "%s\n" "${pythonpath_tmp[@]}")
	EOF
}

_pathmod_usage() {
	# Script that prints usage information
	cat <<- EOF
	usage: $PATHMOD_PROGNAME options

	Program enables you to easily check, add, move and remove paths from the PATH or PYTHONPATH
	enviromental variables.

	OPTIONS:
	   -a  --add                 add path(s) to the PATH or PYTHONPATH
	   -i  --index               index where to add the path(s) (OPTIONAL: 0=start, -1=end, defaults to -1)
	   -m  --move                move a path to a given index (Adds path if not yet present.)
	   -r  --remove              remove path(s) from the PATH or PYTHONPATH
	   -c  --check               check if path exists in the PATH or PYTHONPATH
	   -h  --help                show this help
	   -v, --version             pathmod version
	   -p  --pythonpath          modify PYTHONPATH instead of PATH
	   -s  --settings            display pathmod settings and the current PATH and PYTHONPATH
	   -sd --set-path-display    display PATH and PYTHONPATH after each command (OPTIONAL, defaults to false)
	   -se --set-export          export path after it is set (OPTIONAL, defaults to true)
	   -sg --set-path-guard      check wheter a path is valid before adding it (OPTIONAL, defaults to false)

	NOTE:
	   Each option only accepts one argument at the same time. To add, remove or check multiple
	   paths please use the colon separator (example: $PATHMOD_PROGNAME --<OPTION> "<PATH1>:<PATH2>").

	Examples:
	   Add path to PATH variable:
	   $PATHMOD_PROGNAME --add <PATH>
	   
	   Add path to PATH at an index:
	   $PATHMOD_PROGNAME --add <PATH> --index <INDEX>

	   Remove path from PATH variable:
	   $PATHMOD_PROGNAME --remove <PATH>

	   Check if path exists in PATH varible:
	   $PATHMOD_PROGNAME --exists <PATH>

	   Move path to a given index:
	   $PATHMOD_PROGNAME --move <PATH> --index <INDEX>

	   Add path from PYTHONPATH variable:
	   $PATHMOD_PROGNAME --pythonpath --add <PATH>
	EOF
}

_pathmod_add_path() {
	# Adds a path to the PATH variable

	# Create local arrays
	local added=()
	local not_added=()
	local not_valid=()

	# Split paths by deliminator
	local defaultIFS="$IFS"; IFS=$' \t\n'; local paths_array=(${@//:/ }); IFS="$defaultIFS"

	# Convert PATH or PYTHONPATH to array
	if [[ "$python_path" == false ]]; then # Add to PATH
		local defaultIFS="$IFS"; IFS=$' \t\n'; local new_path=(${PATH//:/ }); IFS="$defaultIFS"
	else
		local defaultIFS="$IFS"; IFS=$' \t\n'; local new_path=(${PYTHONPATH//:/ }); IFS="$defaultIFS"
	fi
	
	# Adjust index if it is out of range
	local arr_len="${#new_path[@]}"
	if [[ "$path_index" -lt -1 ]]; then
		path_index=0
	elif [[ "$path_index" -gt "$arr_len" ]]; then
		path_index=-1
	fi

	# Loop through paths and add them if do not yet exist
	if [[ "$python_path" == false ]]; then # Add to PATH
		local path_type="PATH"
		for (( i=${#paths_array[@]}-1 ; i>=0 ; i-- )) ; do

				# Check if path exists on PATH
				if [[ ":$PATH:" != *":${paths_array[i]}:"* ]]; then

					# Check if path is valid
					if [[ -e "${paths_array[i]}" ]]; then 

						# Add path to PATH variable
						if [[ "$path_index" == -1 ]]; then
	
							# Append to PATH variable
							new_path="${PATH:+${PATH}:}${paths_array[i]}" 
						elif [[ "$path_index" == 0 ]]; then
							
							# Prepent to PATH variable
							new_path="${paths_array[i]}${PATH:+:${PATH}}" 
						else
	
							# Add path to PATH variable at index
							new_path=( "${new_path[@]:0:$path_index}" "${paths_array[i]}" "${new_path[@]:$path_index:${arr_len[@]}}" )
						fi
						
						# The directory is added on the path
						added+=(${paths_array[i]})
					else
						# The directory was not added because it was not valid
						not_valid+=(${paths_array[i]})
					fi
				else
					# The directory was already on the path and thus not added
					not_added+=(${paths_array[i]})
				fi
		done

		# Convert PATH array back to string
		new_path=$( IFS=$':'; echo "${new_path[*]}" ) # Converting bash array into a delimited string
		PATH="$new_path"
	else # Add to PYTHONPATH
		local path_type="PYTHONPATH"
		for (( i=${#paths_array[@]}-1 ; i>=0 ; i-- )) ; do

				# Check if path exists
				if [[ ":$PYTHONPATH:" != *":${paths_array[i]}:"* ]]; then

					# Check if path is valid
					if [[ -e "${paths_array[i]}" ]]; then 

						# Add path to PATH variable
						if [[ "$path_index" == -1 ]]; then

							# Append to PATH variable
							new_path="${PYTHONPATH:+${PYTHONPATH}:}${paths_array[i]}" 
						elif [[ "$path_index" == 0 ]]; then

							# Prepent to PATH variable
							new_path="${paths_array[i]}${PATH:+:${PYTHONPATH}}" 
						else

							# Add path to PATH variable at index
							new_path=( "${new_path[@]:0:$path_index}" "${paths_array[i]}" "${new_path[@]:$path_index:${arr_len[@]}}" )
						fi

						# The directory is added on the path
						added+=(${paths_array[i]})
					else
						# The directory was not added because it was not valid
						not_valid+=(${paths_array[i]})
					fi
				else
					# The directory was already on the path and thus not added
					not_added+=(${paths_array[i]})
				fi
		done

		# Convert PATH array back to string
		new_path=$( IFS=$':'; echo "${new_path[*]}" ) # Converting bash array into a delimited string
		PYTHONPATH="$new_path"
	fi

	# Prepent - to added and not_added arrays
	added=( "${added[@]/#/" - "}" )
	not_added=( "${not_added[@]/#/" - "}" )
	not_valid=( "${not_valid[@]/#/" - "}" )

	# Print result messages
	if ! [[ "${#added[@]}" -eq 0 ]]; then
		if [[ "$path_index" -eq 0 ]]; then
			if [[ "$move_on" == false ]]; then
				printf "Paths that were succesfully prepended to the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			else
				printf "Paths that were succesfully moved to the beginning of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			fi
		elif [[ "$path_index" -eq -1 ]]; then
			if [[ "$move_on" == false ]]; then
				printf "Paths that were succesfully appended to the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			else
				printf "Paths that were succesfully moved to the end of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			fi
		else
			if [[ "$move_on" == false ]]; then
				printf "Paths that were succesfully added to index $path_index of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			else
				printf "Paths that were succesfully moved to index $path_index of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			fi
		fi
	fi
	if ! [[ "${#not_added[@]}" -eq 0 ]]; then
		printf "Paths that were already found on the $path_type variable and were thus not added:\n"
		printf '%s\n' "${not_added[@]}"
	fi
	if ! [[ "${#not_valid[@]}" -eq 0 ]]; then
		printf "Paths that were not valid and thus were not added to the path:\n"
		printf '%s\n' "${not_valid[@]}"
	fi
}

_pathmod_remove_path() {
	# Removes a path from the PATH variable

	# Create local arrays
	local found=()
	local not_found=()

	# Split path by deliminator
	local defaultIFS="$IFS"; IFS=$' \t\n'; local paths_array=(${@//:/ }); IFS="$defaultIFS"

	# Check if path was supplied or that only an idex was given
	if [[ "$#" -eq 0 ]]; then

		# Convert PATH or PYTHONPATH to array
		if [[ "$python_path" == false ]]; then # Add to PATH
			local defaultIFS="$IFS"; IFS=$' \t\n'; local new_path=(${PATH//:/ }); IFS="$defaultIFS"
		else
			local defaultIFS="$IFS"; IFS=$' \t\n'; local new_path=(${PYTHONPATH//:/ }); IFS="$defaultIFS"
		fi

		# Check if path index was within range
		local arr_len="${#new_path[@]}"
		if [[ "$path_index" -lt 0 ]]; then
			printf "%s:${ORANGE}warning:${NC} Path could not be remove since remove index %s is not valid. %s\n" "$PATHMOD_PROGNAME" "$path_index"
			return 1
		elif [[ "$path_index" -gt "$arr_len" ]]; then
			printf "%s:${ORANGE}warning:${NC} Path could not be remove since remove index %s is not valid. %s\n" "$PATHMOD_PROGNAME" "$path_index"
			return 1
		fi

		# Modify path such that index element is present
		paths_array=(${paths_array[path_index]})
	fi

	## Remove paths from PATH
	# Loop through paths and remove them if they exist
	# Delete path by parts so we can never accidentally remove sub paths
	if [[ "$python_path" == false ]]; then # Remove from PATH
		local path_type="PATH"
		for i in "${paths_array[@]}"; do
			if [[ ":$PATH:" == *:"$i":* ]]  ; then

				# Remove all occurances from PATH variable
				while [[ ":$PATH:" == *:"$i":* ]] ; do 
					# Remove path from PATH variable
					PATH=${PATH//":$i:"/":"} # delete any instances in the middle
					PATH=${PATH/#"$i:"/} # delete any instance at the beginning
					PATH=${PATH/%":$i"/} # delete any instance in the at the end
				done
				
				# The directory was on the path and is thus removed
				found+=($i)

			else
				# The directory was not on the path so can could not be removed
				not_found+=($i)
			fi
		done
	else # Remove from PYTHONPATH
		local path_type="PATH"
		for i in "${paths_array[@]}"; do
			if [[ ":$PYTHONPATH:" == *:"$i":* ]]  ; then

				# Remove all occurances from PATH variable
				while [[ ":$PYTHONPATH:" == *:"$i":* ]] ; do 
					# Remove path from PATH variable
					PYTHONPATH=${PYTHONPATH//":$i:"/":"} # delete any instances in the middle
					PYTHONPATH=${PYTHONPATH/#"$i:"/} # delete any instance at the beginning
					PYTHONPATH=${PYTHONPATH/%":$i"/} # delete any instance in the at the end
				done
				
				# The directory was on the path and is thus removed
				found+=($i)

			else
				# The directory was not on the path so can could not be removed
				not_found+=($i)
			fi
		done
	fi

	# Prepent - to found and not_found arrays
	found=( "${found[@]/#/" -"}" )
	not_found=( "${not_found[@]/#/" -"}" )

	# Print result messages
	if [[ "$move_on" == false ]]; then
		if ! [[ ${#found[@]} -eq 0 ]]; then
			printf "Paths that were succesfully removed from the $path_type variable:\n"
			printf '%s\n' "${found[@]}"
		fi
		if ! [[ "${#not_found[@]}" -eq 0 ]]; then
			printf "Paths that were not found on the $path_type variable and could not be removed:\n"
			printf '%s\n' "${not_found[@]}"
		fi
	fi

	# Set return value
	return 0
}

_move_path() {
	# Moves a path to a given index
	move_on=true # Tell the functions used below the call to them was made from the _move_path function

	# Remove paths from PATH or PYTHONPATH
	_pathmod_remove_path "$@"

	# Add path at a given index
	_pathmod_add_path "$@"
	move_on=false # Disable move_bool again
}

_pathmod_path_exists() {
	# Checks if a path exists in the PATH variable

	# Create local arrays
	local found=()
	local not_found=()

	# Split path by deliminator
	local defaultIFS="$IFS"; IFS=$' \t\n'; local paths_array=(${@//:/ }); IFS="$defaultIFS"

	# Loop through paths and check if they exist in PATH or PYTHONPATH
	if [[ "$python_path" == false ]]; then # Check PATH
		local path_type="PATH"
		for i in "${paths_array[@]}"; do
			if [[ ":$PATH:" == *:"$i":* ]] ; then

				# O.K., the directory is on the path
				found+=(" - "$i)
			else

				# The directory is not on the path
				not_found+=(" - "$i)
			fi
		done
	else # Check PYTHONPATH
		local path_type="PYTHONPATH"
		for i in "${paths_array[@]}"; do
			if [[ ":$PYTHONPATH:" == *:"$i":* ]] ; then

				# O.K., the directory is on the path
				found+=(" - "$i)
			else

				# The directory is not on the path
				not_found+=(" - "$i)
			fi
		done
	fi

	# Print result
	if ! [[ "${#found[@]}" -eq 0 ]]; then
		printf "Paths that were found on the $path_type variable:\n"
		printf '%s\n' "${found[@]}"
	fi
	if ! [[ "${#not_found[@]}" -eq 0 ]]; then
		printf "Paths that were not found on the $path_type variable:\n"
		printf '%s\n' "${not_found[@]}"
	fi
}

_pathmod_cmdline() {
	# Commmand line parser
	# got this idea from here:
	# http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/
	local arg="$@"
	local args=() # Make args variable local (needed since script is sourced)
	OPTIND=1 # Reset OPTIND (Needed since the script is sourced)
	local path_index=-1
	local opt_a=false
	local opt_i=false
	local opt_m=false
	local opt_r=false
	local move_on=false
	local python_path=false
	local move_index_warning=false

	# Translate long options to short options
	for arg
	do
		local delim=""
		case "$arg" in
			# Translate --gnu-long-options to -g (short options)
			--add)         	      args="${args}-a ";;
			--index)              args="${args}-i ";;
			--move)               args="${args}-m ";;
			--remove)             args="${args}-r ";;
			--check)              args="${args}-c ";;
			--help)               args="${args}-h ";;
			--version)            args="${args}-v ";;
			----pythonpath)       args="${args}-p ";;
			--settings)		      args="${args}-s ";;
			-se)			      args="${args}-e ";;
			--set-export)         args="${args}-e ";;
			-sd)  				  args="${args}-d ";;
			--set-path-display)   args="${args}-d ";;
			-sg)                  args="${args}-g ";; 
			--set-path-guard)     args="${args}-g ";;
			# Pass through anything else
			*) [[ "${arg:0:1}" == "-" ]] || delim="\""
				args="${args}${delim}${arg}${delim} ";;
		esac
	done

	# Print help if no option was given
	if [[ "$#" -eq 0 ]]
  	then
  	  	_pathmod_usage
		return 0
	fi

	#Reset the positional parameters to the short options
	eval set -- "$args"

	# Get options
	# Check dependent options
	while getopts ":a:i:m:r:c:e:d:g:hvsp" OPTION
	do
		case "$OPTION" in
		a)
			# Set option boolean
			opt_a=true
			;; # Main code in next getopts switch
		i)
			# Validate index
			re='^-?[0-9]+$'
			if ! [[ "$OPTARG" =~ $re ]] ; then
				printf "$PATHMOD_PROGNAME:${RED}error:${NC} Index is not a number" >&2
			   	_pathmod_usage
			   	return 1
			fi

			# set index
		 	path_index=$OPTARG
			opt_i=true
			;;
		m)
			# Set option boolean
			opt_m=true
			;; # Main code in next getopts switch
		r)	
			# Set option boolean
			opt_r=true
			;; # Main code in next getopts switch
		c)
			# Set option boolean
			opt_c=true
			;; # Pass to next getopt switch
		h)
		 	_pathmod_usage
			return 0
			;;
		v)
			echo "v$PATHMOD_VERSION"
			return 0
			;;
		p)
			python_path=true
			;;
		s)

			# List settings
			_list_settings
			return 0
			;;
		e)
			# Check input value and change export settings
			case "$OPTARG" in
				"true"|"True"|"TRUE"|1)

					# Set path export variable to true
					if [[ "$path_export" == true ]]; then
						printf "%s: path_export boolean already set to true.\n" "$PATHMOD_PROGNAME"
					else
						printf "%s: path_export boolean set to true.\n" "$PATHMOD_PROGNAME"
						path_export=true
					fi
					;;	
				"false"|"False"|"FALSE"|0)

					# Set path export variable to false					
					if [[ "$path_export" == false ]]; then
						printf "%s: path_export boolean already set to false.\n" "$PATHMOD_PROGNAME"
					else
						printf "%s: path_export boolean set to false.\n" "$PATHMOD_PROGNAME"
						path_export=false
					fi
					;;
				*)
					printf "%s: path_export boolean kept on %s since %s in not a valid value.\n" "$PATHMOD_PROGNAME" "$path_export" "$OPTARG"
					;;
			esac

			# Save values to config file
			_pathmod_save_config_vars
			;;
		d)
			# Check input value and change export settings
			case "$OPTARG" in
				"true"|"True"|"TRUE"|1)

					# Set path export variable to true
					if [[ "$path_display" == true ]]; then
						printf "%s: path_display boolean already set to true.\n" "$PATHMOD_PROGNAME"
					else
						printf "%s: path_display boolean set to true.\n" "$PATHMOD_PROGNAME"
						path_display=true
					fi
					;;	
				"false"|"False"|"FALSE"|0)

					# Set path export variable to false					
					if [[ "$path_display" == false ]]; then
						printf "%s: path_display boolean already set to false.\n" "$PATHMOD_PROGNAME"
					else
						printf "%s: path_display boolean set to false.\n" "$PATHMOD_PROGNAME"
						path_display=false
					fi
					;;
				*)
					printf "%s: path_display boolean kept on %s since %s in not a valid value.\n" "$PATHMOD_PROGNAME" "$path_display" "$OPTARG"
					;;
			esac

			# Save values to config file
			_pathmod_save_config_vars
			;;
		g)
			# Check input value and change export settings
			case "$OPTARG" in
				"true"|"True"|"TRUE"|1)

					# Set path export variable to true
					if [[ "$path_guard" == true ]]; then
						printf "%s: path_guard boolean already set to true.\n" "$PATHMOD_PROGNAME"
					else
						printf "%s: path_guard boolean set to true.\n" "$PATHMOD_PROGNAME"
						path_guard=true
					fi
					;;	
				"false"|"False"|"FALSE"|0)

					# Set path export variable to false					
					if [[ "$path_guard" == false ]]; then
						printf "%s: path_guard boolean already set to false.\n" "$PATHMOD_PROGNAME"
					else
						printf "%s: path_guard boolean set to false.\n" "$PATHMOD_PROGNAME"
						path_guard=false
					fi
					;;
				*)
					printf "%s: path_display boolean kept on %s since %s in not a valid value.\n" "$PATHMOD_PROGNAME" "$path_guard" "$OPTARG"
					;;
			esac

			# Save values to config file
			_pathmod_save_config_vars
			;;
		:)	
			# Pass empty remove statement to next getopt switch
			if [[ "$OPTARG" == "r" ]]; then
				opt_r=true
			else
				# Trow error
		 		printf "$PATHMOD_PROGNAME:${RED}error:${NC} option requires an argument -- %s\n" "$OPTARG"
				_pathmod_usage
				return 1
			fi
			;;
		?)
			printf "$PATHMOD_PROGNAME:${RED}error:${NC} invalid option was specified -%s\n" "$OPTARG"
			_pathmod_usage
			return 1
			;;
		esac
	done

	# Check required arguments
	if [[ "$opt_a" == true || "$opt_m" == true || "$opt_c" == true || "$opt_r" == true ]]; then
		printf "Results:%s\n\n" "$PATHMOD_PROGNAME"
	fi
	unset OPTIND
	while getopts ":a:i:m:r:c:e:d:g:hvsp" OPTION
	do
		case "$OPTION" in
		a)
		 	# Add path
			_pathmod_add_path "$OPTARG"
			;;
		i)
			;; # Already handled by first getopts switch
		m)
			# Check if index was specified if not display warning
			if [[ "$opt_i" == false ]]; then
				printf "%s:${ORANGE}warning:${NC} Path could not be moved since no index was supplied.\n" "$PATHMOD_PROGNAME"
				move_index_warning=true
			else
				# Move path
				_move_path "$OPTARG"
			fi
			;;
		r)
			# Remove path
			_pathmod_remove_path "$OPTARG"
			
			# Check if remove was succesfull
			if [[ "$?" -eq 1 ]]; then
				opt_r=false
				return 1
			else
				return 0
			fi
			;;
		c)
			# Check if path exists
		 	_pathmod_path_exists "$OPTARG"
			;;
		h)
			;; # Already handled by first getopts switch
		v)
			;; # Already handled by first getopts switch
		p)
			;; # Already handled by first getopts switch
		s)
			;; # Already handled by first getopts switch
		e)
			;; # Already handled by first getopts switch
		d)
			;; # Already handled by first getopts switch
		g)
			;; # Already handled by first getopts switch
		:)	
			# Check if remove was empty while index was specified
			if [[ "$OPTARG" == "r" && "$opt_i" == true ]]; then
				
				# Call remove path without argument
				_pathmod_remove_path

				# Check if remove was succesfull
				if [[ "$?" -eq 1 ]]; then
					opt_r=false
					return 1
				fi
			else # Throw error
		 		printf "$PATHMOD_PROGNAME:${RED}error:${NC} option requires an argument -- %s\n" "$OPTARG"
				_pathmod_usage
				return 1
			fi
			;;
		?)
		 	printf "$PATHMOD_PROGNAME:${RED}error:${NC} invalid option was specified -%s\n" "$OPTARG"
			_pathmod_usage
			return 1
			;;
		esac
	done

	# Export path such that it gets passed on to child processes
	if [[ "$path_export" == "true" && (( "$opt_a" == true || "$opt_r" == true ) || ( "$opt_m" == true && "$move_index_warning" == false )) ]]; then
		if [[ "$python_path" == false ]]; then
			printf "PATH variable exported.\n"
			export PATH
		else
			printf "PYTHONPATH variable exported.\n"
			export PYTHONPATH
		fi
	fi

	# Display PATH and PYTHONPATH
	if [[ "$path_display" == "true" && (( "$opt_a" == true || "$opt_r" == true ) || ( "$opt_m" == true && "$move_index_warning" == false )) ]]; then
		_list_path		
	fi
			
	# Reset warning booleans
	move_index_warning=false

	# Display warning if index was specified but no path was added or moved
	if [[ "$opt_i" == true && ! ( ! "$opt_a" == false || ! "$opt_m" == false || ! "$opt_r" == false ) ]]; then
		printf "%s:${ORANGE}warning:${NC} index (-i) option was ignored since no path was found to be added or moved.\n" "$PATHMOD_PROGNAME"
	fi
}

_pathmod_wrapper() {
	# Pathmod alias function
	_pathmod_cmdline "$@"
}

main(){
	# Main function

	# Load configuration values
	_pathmod_load_config_vars

	# Create pathnmod alias
	alias pathmod='_pathmod_wrapper "$@"'
}

# Execute main function
main "$@"