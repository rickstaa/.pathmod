#!/usr/bin/env bash
## -- PATHMOD bash wrapper --
# A bash script that eases the way of modifying the bash PATH and PYTHONPATH enviromental variables.

# Add Global variables
PROGNAME="pathmod"
CONFIG_FILE_NAME="${HOME}/.pathmod_cfg"
VERSION="0.0.0"

# Unset previoussly set functions and aliases
unset -f _usage
unset -f _add_path
unset -f _remove_path
unset -f _path_exists
unset -f _pathmod_wrapper
unset -f _cmdline

# Bash echo colors
ORANGE='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

_load_config_vars() {
	# Load saved variables
	if [[ -a $CONFIG_FILE_NAME ]]; then

		# Read variables from file
		while IFS="=" read -r key val; do
			case "$key" in
				'#'*) 
					;; # Skip comments
				'path_export'|'path_display')
					eval "$key=\"$val\""
					;;
			esac
		done < $CONFIG_FILE_NAME

		# Parse variables to make sure they are alright
		case $path_export in
			"true"|"True"|"TRUE"|"false"|"False"|"FALSE")
				;;	
			*)
				# Value was not valid set to default
				path_export=true
				;;
		esac
		case $path_display in
			"true"|"True"|"TRUE"|"false"|"False"|"FALSE")
				;;	
			*)
				# Value was not valid set to default
				path_export=false
				;;
		esac
	else

		# Create file
		{ 
		cat >"$HOME"/.pathmod_cfg <<- EOL
		# Pathnmod settings
		path_export=true
		path_display=false
		EOL
		} || {
			printf "%s:${ORANGE}warning:${NC} Configuration file could not be loaded. Default values were used instead. %s\n" "$PROGNAME"		
		}

		# Use defaults
		path_export=true
		path_display=false
	fi

}

_save_config_vars() {
		# Save the pathmod configuration values
		{
		cat >"$HOME"/.pathmod_cfg <<- EOL
		# Pathnmod settings
		path_export=$path_export
		path_display=$path_display
		EOL
		} || {
			printf "%s:${ORANGE}warning:${NC} Pathmod configuration values could not be saved. %s\n" "$PROGNAME"		
		}
}

_list_settings() {
	# List current settings and paths
	cat <<- EOF
	current settings and values: $PROGNAME (v$VERSION)

	SETTINGS:
	   - Path export: $path_export
	   - Path display: $path_display
	$(_list_path)
	EOF
}

_list_path() {
	# List the current PATH and PYTHONPATH

	# Split path into array 
	path_tmp=($(echo $PATH | tr ":" "\n"))
	for ((i=0;i<${#path_tmp[@]};i++)); do     path_tmp[i]=" - [$i] ${path_tmp[i]}"; done
	pythonpath_tmp=($(echo $PYTHONPATH | tr ":" "\n"))
	for ((i=0;i<${#pythonpath_tmp[@]};i++)); do     pythonpath_tmp[i]=" - [$i] ${pythonpath_tmp[i]}"; done
	
	# Print PATH and PYTHONPATH
	cat <<- EOF

	PATH:
	$(printf "%s\n" "${path_tmp[@]}")

	PYTHONPATH:
	$(printf "%s\n" "${pythonpath_tmp[@]}")
	EOF
}

_usage() {
	# Script that prints usage information
	cat <<- EOF
	usage: $PROGNAME options

	Program enables you to easily check, add, move and remove paths from the PATH or PYTHONPATH
	enviromental variables.

	OPTIONS:
	   -a  --add                 add path(s) to the PATH or PYTHONPATH
	   -i  --index               index where to add the path(s) (OPTIONAL: 0=start, -1=end, defaults to -1)
	   -m  --move				 move a path to a given index (Adds path if not yet present.)
	   -r  --remove              remove path(s) from the PATH or PYTHONPATH
	   -c  --check               check if path exists in the PATH or PYTHONPATH
	   -h  --help                show this help
	   -p  --pythonpath          modify PYTHONPATH instead of PATH
	   -s  --settings            display pathmod settings and the current PATH and PYTHONPATH
	   -sd --set-path-display    display PATH and PYTHONPATH after each command (OPTIONAL, defaults to false)
	   -se --set-export          export path after it is set (OPTIONAL, defaults to true)

	NOTE:
	   Each option only accepts one argument at the same time. To add, remove or check multiple
	   paths please use the colon separator (example: $PROGNAME --<OPTION> "<PATH1>:<PATH2>").

	Examples:
	   Add path to PATH variable:
	   $PROGNAME --add <PATH>
	   
	   Add path to PATH at an index:
	   $PROGNAME --add <PATH> --index <INDEX>

	   Remove path from PATH variable:
	   $PROGNAME --remove <PATH>

	   Check if path exists in PATH varible:
	   $PROGNAME --exists <PATH>

	   Move path to a given index:
	   $PROGNAME --move <PATH> --index <INDEX>

	   Add path from PYTHONPATH variable:
	   $PROGNAME --pythonpath --add <PATH>
	EOF
}

_add_path() {
	# Adds a path to the PATH variable

	# Create local arrays
	local added=()
	local not_added=()

	# Split paths by deliminator
	local paths_array=($(echo $@ | tr ":" "\n"))

	# Convert PATH or PYTHONPATH to array
	if [[ $python_path == false ]]; then # Add to PATH
		local new_path=($(echo $PATH | tr ":" "\n")) # Split path into array 
	else
		local new_path=($(echo $PYTHONPATH | tr ":" "\n")) # Split path into array 
	fi
	
	# Adjust index if it is out of range
	local arr_len=${#new_path[@]}
	if [[ $path_add_index -lt -1 ]]; then
		path_add_index=0
	elif [[ $path_add_index -gt $arr_len ]]; then
		path_add_index=-1
	fi

	# Loop through paths and add them if do not yet exist
	if [[ $python_path == false ]]; then # Add to PATH
		local path_type="PATH"
		for (( i=${#paths_array[@]}-1 ; i>=0 ; i-- )) ; do

				# Check if path exists
				if [[ ":$PATH:" != *":${paths_array[i]}:"* ]]; then

					# Add path to PATH variable
					if [[ "$path_add_index" == -1 ]]; then

						# Append to PATH variable
						PATH="${PATH:+${PATH}:}${paths_array[i]}" 
					elif [[ "$path_add_index" == 0 ]]; then
						
						# Prepent to PATH variable
						PATH="${paths_array[i]}${PATH:+:${PATH}}" 
					else

						# Add path to PATH variable at index
						new_path=( "${new_path[@]:0:$path_add_index}" ${paths_array[i]} "${new_path[@]:$path_add_index:${arr_len[@]}}" )
					fi

					# The directory is added on the path
					added+=(${paths_array[i]})
				else
					# The directory was already on the path and thus not added
					not_added+=(${paths_array[i]})
				fi
		done

		# Convert PATH array back to string
		if ! [[ "$path_add_index" == -1 ]] && ! [[ "$path_add_index" == 0 ]]; then
			new_path=$( IFS=$':'; echo "${new_path[*]}" ) # Converting bash array into a delimited string
			PATH=$new_path
		fi
	else # Add to PYTHONPATH
		local path_type="PYTHONPATH"
		for (( i=${#paths_array[@]}-1 ; i>=0 ; i-- )) ; do

				# Check if path exists
				if [[ ":$PYTHONPATH:" != *":${paths_array[i]}:"* ]]; then

					# Add path to PATH variable
					if [[ "$path_add_index" == -1 ]]; then

						# Append to PATH variable
						PYTHONPATH="${PYTHONPATH:+${PYTHONPATH}:}${paths_array[i]}" 
					elif [[ "$path_add_index" == 0 ]]; then
						
						# Prepent to PATH variable
						PYTHONPATH="${paths_array[i]}${PATH:+:${PYTHONPATH}}" 
					else

						# Add path to PATH variable at index
						new_path=( "${new_path[@]:0:$path_add_index}" ${paths_array[i]} "${new_path[@]:$path_add_index:${arr_len[@]}}" )
					fi

					# The directory is added on the path
					added+=(${paths_array[i]})
				else
					# The directory was already on the path and thus not added
					not_added+=(${paths_array[i]})
				fi
		done

		# Convert PATH array back to string
		if ! [[ "$path_add_index" == -1 ]] && ! [[ "$path_add_index" == 0 ]]; then
			new_path=$( IFS=$':'; echo "${new_path[*]}" ) # Converting bash array into a delimited string
			PYTHONPATH=$new_path
		fi
	fi

	# Prepent - to added and not_added arrays
	added=( "${added[@]/#/" - "}" )
	not_added=( "${not_added[@]/#/" - "}" )

	# Print result messages
	if ! [[ ${#added[@]} -eq 0 ]]; then
		if [[ $path_add_index -eq 0 ]]; then
			if [[ $move_on == false ]]; then
				printf "Paths that were succesfully prepended to the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			else
				printf "Paths that were succesfully moved to the beginning of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			fi
		elif [[ $path_add_index -eq -1 ]]; then
			if [[ $move_on == false ]]; then
				printf "Paths that were succesfully appended to the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			else
				printf "Paths that were succesfully moved to the end of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			fi
		else
			if [[ $move_on == false ]]; then
				printf "Paths that were succesfully added to index $path_add_index of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			else
				printf "Paths that were succesfully moved to index $path_add_index of the $path_type variable:\n"
				printf '%s\n' "${added[@]}"
			fi
		fi
	fi
	if ! [[ ${#not_added[@]} -eq 0 ]]; then
		printf "Paths that were already found on the $path_type variable and were thus not added:\n"
		printf '%s\n' "${not_added[@]}"
	fi
}

_remove_path() {
	# Removes a path from the PATH variable

	# Create local arrays
	local found=()
	local not_found=()

	# Split path by deliminator
	local paths_array=($(echo $@ | tr ":" "\n"))
	
	## Remove paths from PATH
	# Loop through paths and remove them if they exist
	# Delete path by parts so we can never accidentally remove sub paths
	if [[ $python_path == false ]]; then # Remove from PATH
		local path_type="PATH"
		for i in "${paths_array[@]}"; do
			if [[ :$PATH: == *:"$i":* ]]  ; then

				# Remove all occurances from PATH variable
				while [[ :$PATH: == *:"$i":* ]] ; do 
					# Remove path from PATH variable
					PATH=${PATH//":$i:"/":"} # delete any instances in the middle
					PATH=${PATH/#"$i:"/} # delete any instance at the beginning
					PATH=${PATH/%":$i"/} # delete any instance in the at the end
				done
				
				# The directory was on the path and is thus removed
				found+=($i)

			else
				# The directory was not on the path so can could not be removed
				not_found+=($i)
			fi
		done
	else # Remove from PYTHONPATH
		local path_type="PATH"
		for i in "${paths_array[@]}"; do
			if [[ :$PYTHONPATH: == *:"$i":* ]]  ; then

				# Remove all occurances from PATH variable
				while [[ :$PYTHONPATH: == *:"$i":* ]] ; do 
					# Remove path from PATH variable
					PYTHONPATH=${PYTHONPATH//":$i:"/":"} # delete any instances in the middle
					PYTHONPATH=${PYTHONPATH/#"$i:"/} # delete any instance at the beginning
					PYTHONPATH=${PYTHONPATH/%":$i"/} # delete any instance in the at the end
				done
				
				# The directory was on the path and is thus removed
				found+=($i)

			else
				# The directory was not on the path so can could not be removed
				not_found+=($i)
			fi
		done
	fi

	# Prepent - to found and not_found arrays
	found=( "${found[@]/#/" -"}" )
	not_found=( "${not_found[@]/#/" -"}" )

	# Print result messages
	if [[ $move_on == false ]]; then
		if ! [[ ${#found[@]} -eq 0 ]]; then
			printf "Paths that were succesfully removed from the $path_type variable:\n"
			printf '%s\n' "${found[@]}"
		fi
		if ! [[ ${#not_found[@]} -eq 0 ]]; then
			printf "Paths that were not found on the $path_type variable and could not be removed:\n"
			printf '%s\n' "${not_found[@]}"
		fi
	fi
}

_move_path() {
	# Moves a path to a given index
	move_on=true # Tell the functions used below the call to them was made from the _move_path function

	# Remove paths from PATH or PYTHONPATH
	_remove_path "$@"

	# Add path at a given index
	_add_path "$@"
	move_on=false # Disable move_bool again
}

_path_exists() {
	# Checks if a path exists in the PATH variable

	# Create local arrays
	local found=()
	local not_found=()

	# Split path by deliminator
	local paths_array=($(echo $@ | tr ":" "\n"))

	# Loop through paths and check if they exist in PATH or PYTHONPATH
	if [[ $python_path == false ]]; then # Check PATH
		local path_type="PATH"
		for i in "${paths_array[@]}"; do
			if [[ :$PATH: == *:"$i":* ]] ; then

				# O.K., the directory is on the path
				found+=(" - "$i)
			else

				# The directory is not on the path
				not_found+=(" - "$i)
			fi
		done
	else # Check PYTHONPATH
		local path_type="PYTHONPATH"
		for i in "${paths_array[@]}"; do
			if [[ :$PYTHONPATH: == *:"$i":* ]] ; then

				# O.K., the directory is on the path
				found+=(" - "$i)
			else

				# The directory is not on the path
				not_found+=(" - "$i)
			fi
		done
	fi

	# Print result
	if ! [[ ${#found[@]} -eq 0 ]]; then
		printf "Paths that were found on the $path_type variable:\n"
		printf '%s\n' "${found[@]}"
	fi
	if ! [[ ${#not_found[@]} -eq 0 ]]; then
		printf "Paths that were not found on the $path_type variable:\n"
		printf '%s\n' "${not_found[@]}"
	fi
}

_cmdline() {
	# Commmand line parser
	# got this idea from here:
	# http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/
	local arg="$@"
	local args=() # Make args variable local (needed since script is sourced)
	OPTIND=1 # Reset OPTIND (Needed since the script is sourced)
	local path_add_index=-1
	local opt_a=false
	local opt_i=false
	local opt_m=false
	local opt_r=false
	local move_on=false
	local python_path=false
	local move_index_warning=false

	# Translate long options to short options
	for arg
	do
		local delim=""
		case "$arg" in
			# Translate --gnu-long-options to -g (short options)
			--add)         	     args="${args}-a ";;
			--index)             args="${args}-i ";;
			--move)              args="${args}-m ";;
			--remove)            args="${args}-r ";;
			--check)             args="${args}-c ";;
			--help)              args="${args}-h ";;
			----pythonpath)      args="${args}-p ";;
			--settings)		     args="${args}-s ";;
			-se)			     args="${args}-e ";;
			--set-export)        args="${args}-e ";;
			-sd)  				 args="${args}-d ";;
			--set-path-display)  args="${args}-d ";;
			#pass through anything else
			*) [[ "${arg:0:1}" == "-" ]] || delim="\""
				args="${args}${delim}${arg}${delim} ";;
		esac
	done

	# Print help if no option was given
	if [ $# -eq 0 ]
  	then
  	  	_usage
		return 0
	fi

	#Reset the positional parameters to the short options
	eval set -- $args

	# Get options
	# Check dependent options
	while getopts ":i:a:m:r:c:e:hspd:" OPTION
	do
		case $OPTION in
		a)
			# Set option boolean
			opt_a=true
			;; # Main code in next getopts switch
		i)
			# Validate index
			re='^-?[0-9]+$'
			if ! [[ $OPTARG =~ $re ]] ; then
				echo "$PROGNAME:${RED}error:${NC} Index is not a number" >&2
			   	_usage
			   	return 1
			fi

			# set index
		 	path_add_index=$OPTARG
			opt_i=true
			;;
		m)
			# Set option boolean
			opt_m=true
			;; # Main code in next getopts switch
		r)	
			# Set option boolean
			opt_r=true
			;; # Main code in next getopts switch
		c)
			# Set option boolean
			opt_c=true
			;; # Pass to next getopt switch
		h)
		 	_usage
			return 0
			;;
		p)
			python_path=true
			;;
		s)

			# List settings
			_list_settings
			return 0
			;;
		e)
			# Check input value and change export settings
			case $OPTARG in
				"true"|"True"|"TRUE"|1)

					# Set path export variable to true
					if [[ $path_export == true ]]; then
						printf "%s: path_export boolean already set to true.\n" "$PROGNAME"
					else
						printf "%s: path_export boolean set to true.\n" "$PROGNAME"
						path_export=true
					fi
					;;	
				"false"|"False"|"FALSE"|0)

					# Set path export variable to false					
					if [[ $path_export == false ]]; then
						printf "%s: path_export boolean already set to false.\n" "$PROGNAME"
					else
						printf "%s: path_export boolean set to false.\n" "$PROGNAME"
						path_export=false
					fi
					;;
				*)
					printf "%s: path_export boolean kept on %s since %s in not a valid value.\n" "$PROGNAME" "$path_export" "$OPTARG"
					;;
			esac

			# Save values to config file
			_save_config_vars
			;;
		d)
			# Check input value and change export settings
			case $OPTARG in
				"true"|"True"|"TRUE"|1)

					# Set path export variable to true
					if [[ $path_display == true ]]; then
						printf "%s: path_display boolean already set to true.\n" "$PROGNAME"
					else
						printf "%s: path_display boolean set to true.\n" "$PROGNAME"
						path_display=true
					fi
					;;	
				"false"|"False"|"FALSE"|0)

					# Set path export variable to false					
					if [[ $path_display == false ]]; then
						printf "%s: path_display boolean already set to false.\n" "$PROGNAME"
					else
						printf "%s: path_display boolean set to false.\n" "$PROGNAME"
						path_display=false
					fi
					;;
				*)
					printf "%s: path_display boolean kept on %s since %s in not a valid value.\n" "$PROGNAME" "$path_display" "$OPTARG"
					;;
			esac

			# Save values to config file
			_save_config_vars
			;;
		:)
		 	printf "$PROGNAME:${RED}error:${NC} option requires an argument -- %s\n" "$OPTARG"
			_usage
			return 1
			;;
		?)
			printf "$PROGNAME:${RED}error:${NC} invalid option was specified -%s\n" "$OPTARG"
			_usage
			return 1
			;;
		esac
	done

	# Check required arguments
	if [[ $opt_a == true || $opt_m == true || $opt_c == true || $opt_r == true ]]; then
		printf "Results:%s\n\n" "$PROGNAME"
	fi
	unset OPTIND
	while getopts ":i:a:m:r:c:e:hspd:" OPTION
	do
		case $OPTION in
		a)
		 	# Add path
			_add_path $OPTARG
			;;
		i)
			;; # Already handled by first getopts switch
		m)
			# Check if index was specified if not display warning
			if [[ $opt_i == false ]]; then
				printf "%s:${ORANGE}warning:${NC} Path could not be moved since no index was supplied. %s\n" "$PROGNAME"
				move_index_warning=true
			else
				# Move path
				_move_path $OPTARG
			fi
			;;
		r)
			# Remove path
			_remove_path $OPTARG
			;;
		c)
			# Check if path exists
		 	_path_exists $OPTARG
			;;
		h)
			;; # Already handled by first getopts switch
		p)
			;; # Already handled by first getopts switch
		s)
			;; # Already handled by first getopts switch
		e)
			;; # Already handled by first getopts switch
		d)
			;; # Already handled by first getopts switch
		:)
		 	printf "$PROGNAME:${RED}error:${NC} option requires an argument -- %s\n" "$OPTARG"
			_usage
			return 1
			;;
		?)
		 	printf "$PROGNAME:${RED}error:${NC} invalid option was specified -%s\n" "$OPTARG"
			_usage
			return 1
			;;
		esac
	done

	# Export path such that it gets passed on to child processes
	if [[ "$path_export" == "true" && (( $opt_a == true || $opt_r == true ) || ( $opt_m == true && $move_index_warning == false )) ]]; then
		if [[ $python_path == false ]]; then
			printf "PATH variable exported.\n"
			export PATH
		else
			printf "PYTHONPATH variable exported.\n"
			export PYTHONPATH
		fi
	fi

	# Display PATH and PYTHONPATH
	if [[ "$path_display" == "true" && (( $opt_a == true || $opt_r == true ) || ( $opt_m == true && $move_index_warning == false )) ]]; then
		_list_path		
	fi
			
	# Reset warning booleans
	move_index_warning=false

	# Display warning if index was specified but no path was added or moved
	if [[ $opt_i == true && ! ( ! $opt_a == false || ! $opt_m == false ) ]]; then
		printf "%s:${ORANGE}warning:${NC} index (-i) option was ignored since no path was found to be added or moved. %s\n" "$PROGNAME"
	fi
}

_pathmod_wrapper() {
	# Pathmod alias function
	_cmdline "$@"
}

main(){
	# Main function

	# Load configuration values
	_load_config_vars

	# Create pathnmod alias
	alias pathmod='_pathmod_wrapper "$@"'
	# _pathmod_wrapper $@
}

# Execute main function
main "$@"